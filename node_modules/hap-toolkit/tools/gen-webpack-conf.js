/*
 * Copyright (C) 2017, hapjs.org. All rights reserved.
 */

const path = require('path')
const fs = require('fs')
const builtinList = require('module').builtinModules
const fsExtra = require('fs-extra')
const webpack = require('webpack')

const { colorconsole } = require('./packager/common/utils')
const info = require('./packager/common/info')
// 暂时暴露全局
global.colorconsole = colorconsole

/**
 * 动态生成 webpack 配置项
 *
 * @param {Object} options - 命令行参数对象
 * @param {Object} [options.debug=false] - 是否开启调试
 * @param {Object} [options.disableSourceMap=false] - 是否禁用 sourcemap
 * @param {Object} [options.optimizeCssAttr=false] - 优化 css 属性
 * @param {Object} [options.optimizeDescMeta=false] - 优化 css 描述数据
 * @param {Object} [options.optimizeTemplateAttr=false] - 优化模板属性
 * @param {Object} [options.optimizeStyleAppLevel] - 优化 app 样式等级
 * @param {Object} [options.optimizeStylePageLevel] - 优化 app 样式等级
 * @param {production|development} mode - webpack mode
 * @returns {WebpackConfiguration}
 */
module.exports = function genWebpackConf (options, mode) {
  // 支持文件扩展名
  const FILE_EXT_LIST = info.name.extList

  // 文件类型
  const UX_TYPE = {
    APP: 'app',
    PAGE: 'page',
    CARD: 'card'

  }
  // 项目目录
  const pathProject = process.cwd()
  // 源代码目录
  const pathSrc = path.join(pathProject, 'src')
  // 输出目标目录
  const nameBuild = 'build'
  // 构建目录
  const pathBuild = path.join(pathProject, nameBuild)
  // 最终发布目录
  const pathDist = path.join(pathProject, 'dist')
  // 打包配置文件
  const nameManifest = 'manifest.json'
  const pathManifest = path.join(pathSrc, nameManifest)
  // 工具目录
  const pathDirname = __dirname
  // 枚举 node 原生模块
  const enumList = ['assert', 'console', 'buffer', 'child_process', 'cluster', 'console', 'constants', 'crypto', 'dgram', 'dns',
    'domain', 'events', 'fs', 'http', 'https', 'module', 'net', 'os', 'path', 'process', 'punycode', 'querystring', 'readline',
    'repl', 'stream', 'string_decoder', 'sys', 'timers', 'tls', 'tty', 'url', 'util', 'vm', 'zlib']
  const externalsList = Object.prototype.toString.call(builtinList) === '[object Array]' ? builtinList : enumList

  // 校验项目工程
  !validateProject()

  // manifest.json对象
  const manifestObj = getManifest(pathManifest)

  // 应用与页面的脚本文件
  const scriptFileList = findUxFilesByManifest()

  // 页面文件
  const uxEntries = buildWebpackEntries(scriptFileList)

  // 配置环境
  const nodeConf = parseEnv()

  const webpackConf = {
    mode,
    entry: uxEntries,
    output: {
      path: pathBuild,
      filename: '[name]'
    },
    module: {
      rules: []
    },
    externals: [nodeExternals],
    plugins: [
      // 定义环境变量
      new webpack.DefinePlugin({
        // 平台：na
        ENV_PLATFORM: JSON.stringify(nodeConf.NODE_PLATFORM),
        // 阶段: dev|test|release
        ENV_PHASE: JSON.stringify(nodeConf.NODE_PHASE),
        ENV_PHASE_DV: nodeConf.NODE_PHASE === 'dev',
        ENV_PHASE_QA: nodeConf.NODE_PHASE === 'test',
        ENV_PHASE_OL: nodeConf.NODE_PHASE === 'prod'
      }),
      // 编译耗时
      function () {
        this.plugin('run', function (compiler, callback) {
          process.webpackDateS = new Date()
          callback()
        })
        this.plugin('watch-run', function (compiler, callback) {
          process.webpackDateS = new Date()
          callback()
        })
        this.plugin('done', function () {
          process.webpackDateE = new Date()
          const secCost = (process.webpackDateE - process.webpackDateS) / 1000
          colorconsole.info(`Build Time Cost: ${secCost}s`)
        })
      }
    ],
    node: {
      global: false
    },
    resolve: {
      modules: [
        'node_modules',
        // 测试用例在test目录下
        path.join(pathProject, 'test')
      ],
      extensions: ['.webpack.js', '.web.js', '.js', '.json'].concat(FILE_EXT_LIST)
    },
    stats: {
      builtAt: false,
      entrypoints: false,
      children: false,
      chunks: false,
      chunkModules: false,
      chunkOrigins: false,
      modules: false,
      version: false,
      assets: false
    }
  }

  // 环境配置
  if (nodeConf.NODE_PHASE === 'dev') {
    // 开发：sourcemap
    if (!options.disableSourceMap) {
      webpackConf.devtool = 'source-map'
    }
  }

  // 加载配置
  loadWebpackConfList()

  module.exports = webpackConf

  /**
   * 尝试加载每个模块的webpack配置
   */
  function loadWebpackConfList () {
    const moduleList = findModuleList(pathDirname)

    // 增加：开发者项目目录下的config文件夹
    // 注意：Hook机制不保证向后兼容
    moduleList.push({ name: '', path: path.join(pathProject, 'config') })
    const { package: appPackageName, versionCode } = manifestObj
    for (let i = 0, len = moduleList.length; i < len; i++) {
      const moduleItem = moduleList[i]
      const fileConf = path.join(moduleItem.path, 'webpack.config.js')
      if (fs.existsSync(fileConf)) {
        try {
          const moduleWebpackConf = require(fileConf)
          if (moduleWebpackConf.postHook) {
            moduleWebpackConf.postHook(webpackConf, {
              appPackageName,
              versionCode,
              nodeConf,
              pathDist,
              pathDirname,
              pathSrc,
              pathBuild
            }, options)
          }
        }
        catch (err) {
          console.error(`加载webpack配置文件[${fileConf}]出错：${err.message}`)
        }
      }
    }
  }

  /**
   * 查找模块列表
   * @param parentDir
   * @return {Array}
   */
  function findModuleList (parentDir) {
    const moduleList = []
    const fileNameList = fs.readdirSync(pathDirname)
    for (let i = 0, len = fileNameList.length; i < len; i++) {
      const fileName = fileNameList[i]
      const filePath = path.join(parentDir, fileName)
      const fileStat = fs.statSync(filePath)
      if (fileStat.isDirectory()) {
        moduleList.push({
          name: fileName,
          path: filePath
        })
      }
    }
    return moduleList
  }

  /**
   * 解析NODE环境的参数
   */
  function parseEnv () {
    const config = {
      // 平台：na
      NODE_PLATFORM: process.env.NODE_PLATFORM,
      // 阶段: dev|test|release
      NODE_PHASE: process.env.NODE_PHASE,
      // 是否注入测试框架
      NODE_TEST: process.env.NODE_TEST
    }
    colorconsole.info(`配置环境：${JSON.stringify(config)}`)
    return config
  }

  /**
   * 验证项目配置正确
   */
  function validateProject () {
    if (!fs.existsSync(pathManifest)) {
      colorconsole.throw(`请确认项目%projectDir%/src/下存在manifest.json文件：${pathManifest}`)
    }

    // 清空build目录
    fsExtra.emptyDirSync(pathBuild)
    // 清空dist路径
    if (fs.existsSync(pathDist)) {
      const zipfiles = fs.readdirSync(pathDist)
      zipfiles.forEach(function (file) {
        const curPath = pathDist + '/' + file
        if (fs.statSync(curPath).isFile()) {
          fs.unlinkSync(curPath)
        }
      })
    }
    return true
  }

  /**
   * 获取manifest文件
   * @param pathManifest
   */
  function getManifest (pathManifest) {
    let config
    if (fs.existsSync(pathManifest)) {
      config = JSON.parse(fs.readFileSync(pathManifest))
    }
    return config || {}
  }

  /**
   * 提取其中的应用和页面脚本文件
   * @return {Array}
   */
  function findUxFilesByManifest () {
    const files = []

    const appPath = info.findScriptFile(path.join(pathSrc, 'app'))
    if (!appPath) {
      colorconsole.throw(`app脚本文件丢失`)
    }
    files.push({ path: appPath, type: UX_TYPE.APP })

    const { router } = manifestObj
    if (manifestObj && router) {
      const pages = router.pages
      const widgets = router.widgets
      extractedItems(files, pages, UX_TYPE.PAGE)
      extractedItems(files, widgets, UX_TYPE.CARD)
    }
    return files
  }

  /**
   * 提取脚本文件
   * @param files
   * @param items
   * @param type
   */
  function extractedItems (files, items, type = '') {
    if (items) {
      Object.keys(items).forEach(item => {
        const meta = items[item]
        // 如果忘记写组件, 则默认为页面的小写
        const compName = meta.component || item.toLowerCase()
        if (!meta || !meta.component) {
          colorconsole.warn(`manifest.json中的路由信息不全: 页面'${item}'没有设置component属性, 默认采用'${compName}'`)
        }
        const itemobj = {}
        itemobj.path = info.findScriptFile(path.join(pathSrc, item, compName))
        itemobj.type = type

        if (!itemobj.path) {
          colorconsole.throw(`manifest.json中路由[${item}]的文件路径[${itemobj.path}]不存在，请及时删除`)
        }
        else {
          files.push(itemobj)
        }
      })
    }
  }

  /**
   * 生成多入口文件配置
   * @param scriptFileList
   */
  function buildWebpackEntries (scriptFileList) {
    const uxEntries = {}
    scriptFileList.forEach(file => {
      const extname = path.extname(file.path)
      const fileName = path.basename(file.path, extname) + '.js'
      let filePath = path.join(path.dirname(file.path), fileName)
      filePath = filePath.replace(/\\/g, '/')
      const buildRelativeName = filePath.match(/src\/(.*)/)[1]
      // 转换为在build目录下的地址
      uxEntries[buildRelativeName] = file.path + '?uxType=' + file.type
    })
    return uxEntries
  }

  /**
   * 使用 node 原生模块增加报错提示
   */
  function nodeExternals (context, request, callback) {
    if (externalsList.indexOf(request) > -1) {
      return callback(new Error(`您当前使用了 ${request}, 快应用不是 node 环境不支持 node 原生模块`), 'commonjs' + ' ' + request)
    }
    callback()
  }
  return webpackConf
}
